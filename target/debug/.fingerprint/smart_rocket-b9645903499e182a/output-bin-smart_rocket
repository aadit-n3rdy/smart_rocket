{"message":"unused import: `matrix::*`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":61,"byte_end":70,"line_start":5,"line_end":5,"column_start":5,"column_end":14,"is_primary":true,"text":[{"text":"use matrix::*;","highlight_start":5,"highlight_end":14}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":57,"byte_end":71,"line_start":5,"line_end":5,"column_start":1,"column_end":15,"is_primary":true,"text":[{"text":"use matrix::*;","highlight_start":1,"highlight_end":15}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `matrix::*`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:5:5\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m5\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0muse matrix::*;\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_imports)]` on by default\u001b[0m\n\n"}
{"message":"unused variable: `v1`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":2539,"byte_end":2541,"line_start":89,"line_end":89,"column_start":13,"column_end":15,"is_primary":true,"text":[{"text":"        let v1 = Vector2::<f32>::from((10.0, 10.0));","highlight_start":13,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_variables)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":2539,"byte_end":2541,"line_start":89,"line_end":89,"column_start":13,"column_end":15,"is_primary":true,"text":[{"text":"        let v1 = Vector2::<f32>::from((10.0, 10.0));","highlight_start":13,"highlight_end":15}],"label":null,"suggested_replacement":"_v1","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused variable: `v1`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:89:13\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m89\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let v1 = Vector2::<f32>::from((10.0, 10.0));\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_v1`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_variables)]` on by default\u001b[0m\n\n"}
{"message":"cannot move out of a mutable reference","code":{"code":"E0507","explanation":"A borrowed value was moved out.\n\nErroneous code example:\n\n```compile_fail,E0507\nuse std::cell::RefCell;\n\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(self) {}\n}\n\nfn main() {\n    let x = RefCell::new(TheDarkKnight);\n\n    x.borrow().nothing_is_true(); // error: cannot move out of borrowed content\n}\n```\n\nHere, the `nothing_is_true` method takes the ownership of `self`. However,\n`self` cannot be moved because `.borrow()` only provides an `&TheDarkKnight`,\nwhich is a borrow of the content owned by the `RefCell`. To fix this error,\nyou have three choices:\n\n* Try to avoid moving the variable.\n* Somehow reclaim the ownership.\n* Implement the `Copy` trait on the type.\n\nThis can also happen when using a type implementing `Fn` or `FnMut`, as neither\nallows moving out of them (they usually represent closures which can be called\nmore than once). Much of the text following applies equally well to non-`FnOnce`\nclosure bodies.\n\nExamples:\n\n```\nuse std::cell::RefCell;\n\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(&self) {} // First case, we don't take ownership\n}\n\nfn main() {\n    let x = RefCell::new(TheDarkKnight);\n\n    x.borrow().nothing_is_true(); // ok!\n}\n```\n\nOr:\n\n```\nuse std::cell::RefCell;\n\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(self) {}\n}\n\nfn main() {\n    let x = RefCell::new(TheDarkKnight);\n    let x = x.into_inner(); // we get back ownership\n\n    x.nothing_is_true(); // ok!\n}\n```\n\nOr:\n\n```\nuse std::cell::RefCell;\n\n#[derive(Clone, Copy)] // we implement the Copy trait\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(self) {}\n}\n\nfn main() {\n    let x = RefCell::new(TheDarkKnight);\n\n    x.borrow().nothing_is_true(); // ok!\n}\n```\n\nMoving a member out of a mutably borrowed struct will also cause E0507 error:\n\n```compile_fail,E0507\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(self) {}\n}\n\nstruct Batcave {\n    knight: TheDarkKnight\n}\n\nfn main() {\n    let mut cave = Batcave {\n        knight: TheDarkKnight\n    };\n    let borrowed = &mut cave;\n\n    borrowed.knight.nothing_is_true(); // E0507\n}\n```\n\nIt is fine only if you put something back. `mem::replace` can be used for that:\n\n```\n# struct TheDarkKnight;\n# impl TheDarkKnight { fn nothing_is_true(self) {} }\n# struct Batcave { knight: TheDarkKnight }\nuse std::mem;\n\nlet mut cave = Batcave {\n    knight: TheDarkKnight\n};\nlet borrowed = &mut cave;\n\nmem::replace(&mut borrowed.knight, TheDarkKnight).nothing_is_true(); // ok!\n```\n\nFor more information on Rust's ownership system, take a look at the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":1538,"byte_end":1540,"line_start":57,"line_end":57,"column_start":22,"column_end":24,"is_primary":false,"text":[{"text":"            for &mut wt in temp_wts.iter_mut() {","highlight_start":22,"highlight_end":24}],"label":"data moved here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":1538,"byte_end":1540,"line_start":57,"line_end":57,"column_start":22,"column_end":24,"is_primary":false,"text":[{"text":"            for &mut wt in temp_wts.iter_mut() {","highlight_start":22,"highlight_end":24}],"label":"move occurs because `wt` has type `Matrix`, which does not implement the `Copy` trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":1544,"byte_end":1563,"line_start":57,"line_end":57,"column_start":28,"column_end":47,"is_primary":true,"text":[{"text":"            for &mut wt in temp_wts.iter_mut() {","highlight_start":28,"highlight_end":47}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/main.rs","byte_start":1544,"byte_end":1563,"line_start":57,"line_end":57,"column_start":28,"column_end":47,"is_primary":false,"text":[{"text":"            for &mut wt in temp_wts.iter_mut() {","highlight_start":28,"highlight_end":47}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of `for` loop","def_site_span":{"file_name":"src/main.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"consider removing the `&mut`","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":1533,"byte_end":1540,"line_start":57,"line_end":57,"column_start":17,"column_end":24,"is_primary":true,"text":[{"text":"            for &mut wt in temp_wts.iter_mut() {","highlight_start":17,"highlight_end":24}],"label":null,"suggested_replacement":"wt","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0507]\u001b[0m\u001b[0m\u001b[1m: cannot move out of a mutable reference\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:57:28\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m57\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            for &mut wt in temp_wts.iter_mut() {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mdata moved here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmove occurs because `wt` has type `Matrix`, which does not implement the `Copy` trait\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mhelp: consider removing the `&mut`: `wt`\u001b[0m\n\n"}
{"message":"cannot borrow `wt` as mutable, as it is not declared as mutable","code":{"code":"E0596","explanation":"This error occurs because you tried to mutably borrow a non-mutable variable.\n\nErroneous code example:\n\n```compile_fail,E0596\nlet x = 1;\nlet y = &mut x; // error: cannot borrow mutably\n```\n\nIn here, `x` isn't mutable, so when we try to mutably borrow it in `y`, it\nfails. To fix this error, you need to make `x` mutable:\n\n```\nlet mut x = 1;\nlet y = &mut x; // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":1674,"byte_end":1676,"line_start":60,"line_end":60,"column_start":25,"column_end":27,"is_primary":true,"text":[{"text":"                        wt.set(i, j, wt.get(i, j) + rng.gen::<f64>() * 10.0 - 5.0);","highlight_start":25,"highlight_end":27}],"label":"cannot borrow as mutable","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider changing this to be mutable","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":1538,"byte_end":1540,"line_start":57,"line_end":57,"column_start":22,"column_end":24,"is_primary":true,"text":[{"text":"            for &mut wt in temp_wts.iter_mut() {","highlight_start":22,"highlight_end":24}],"label":null,"suggested_replacement":"mut wt","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0596]\u001b[0m\u001b[0m\u001b[1m: cannot borrow `wt` as mutable, as it is not declared as mutable\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:60:25\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m57\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            for &mut wt in temp_wts.iter_mut() {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mhelp: consider changing this to be mutable: `mut wt`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m60\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                        wt.set(i, j, wt.get(i, j) + rng.gen::<f64>() * 10.0 - 5.0);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot borrow as mutable\u001b[0m\n\n"}
{"message":"cannot borrow `*window` as mutable, as it is behind a `&` reference","code":{"code":"E0596","explanation":"This error occurs because you tried to mutably borrow a non-mutable variable.\n\nErroneous code example:\n\n```compile_fail,E0596\nlet x = 1;\nlet y = &mut x; // error: cannot borrow mutably\n```\n\nIn here, `x` isn't mutable, so when we try to mutably borrow it in `y`, it\nfails. To fix this error, you need to make `x` mutable:\n\n```\nlet mut x = 1;\nlet y = &mut x; // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":2039,"byte_end":2045,"line_start":73,"line_end":73,"column_start":9,"column_end":15,"is_primary":true,"text":[{"text":"        window.draw(&circle);","highlight_start":9,"highlight_end":15}],"label":"`window` is a `&` reference, so the data it refers to cannot be borrowed as mutable","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider changing this to be a mutable reference","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":1940,"byte_end":1953,"line_start":71,"line_end":71,"column_start":32,"column_end":45,"is_primary":true,"text":[{"text":"    pub fn draw(&self, window: &RenderWindow) {","highlight_start":32,"highlight_end":45}],"label":null,"suggested_replacement":"&mut sfml::graphics::RenderWindow","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0596]\u001b[0m\u001b[0m\u001b[1m: cannot borrow `*window` as mutable, as it is behind a `&` reference\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:73:9\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m71\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    pub fn draw(&self, window: &RenderWindow) {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mhelp: consider changing this to be a mutable reference: `&mut sfml::graphics::RenderWindow`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m72\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let circle = CircleShape::new(rocket_radius, rocket_point_count);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m73\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        window.draw(&circle);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`window` is a `&` reference, so the data it refers to cannot be borrowed as mutable\u001b[0m\n\n"}
{"message":"allocations are not allowed in constants","code":{"code":"E0010","explanation":"The value of statics and constants must be known at compile time, and they live\nfor the entire lifetime of a program. Creating a boxed value allocates memory on\nthe heap at runtime, and therefore cannot be done at compile time.\n\nErroneous code example:\n\n```compile_fail,E0010\n#![feature(box_syntax)]\n\nconst CON : Box<i32> = box 0;\n```\n"},"level":"error","spans":[{"file_name":"/home/aadit/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/macros.rs","byte_start":1352,"byte_end":1365,"line_start":45,"line_end":45,"column_start":25,"column_end":38,"is_primary":true,"text":[{"text":"        <[_]>::into_vec(box [$($x),+])","highlight_start":25,"highlight_end":38}],"label":"allocation not allowed in constants","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/main.rs","byte_start":510,"byte_end":526,"line_start":23,"line_end":23,"column_start":40,"column_end":56,"is_primary":false,"text":[{"text":"const rocket_ptron_shape: Vec<usize> = vec!(8, 8, 8, 2);","highlight_start":40,"highlight_end":56}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"vec!","def_site_span":{"file_name":"/home/aadit/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/macros.rs","byte_start":1148,"byte_end":1375,"line_start":37,"line_end":47,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! vec {","highlight_start":1,"highlight_end":1},{"text":"    () => (","highlight_start":1,"highlight_end":1},{"text":"        $crate::vec::Vec::new()","highlight_start":1,"highlight_end":1},{"text":"    );","highlight_start":1,"highlight_end":1},{"text":"    ($elem:expr; $n:expr) => (","highlight_start":1,"highlight_end":1},{"text":"        $crate::vec::from_elem($elem, $n)","highlight_start":1,"highlight_end":1},{"text":"    );","highlight_start":1,"highlight_end":1},{"text":"    ($($x:expr),+ $(,)?) => (","highlight_start":1,"highlight_end":1},{"text":"        <[_]>::into_vec(box [$($x),+])","highlight_start":1,"highlight_end":1},{"text":"    );","highlight_start":1,"highlight_end":1},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0010]\u001b[0m\u001b[0m\u001b[1m: allocations are not allowed in constants\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:23:40\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m23\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mconst rocket_ptron_shape: Vec<usize> = vec!(8, 8, 8, 2);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mallocation not allowed in constants\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"calls in constants are limited to constant functions, tuple structs and tuple variants","code":{"code":"E0015","explanation":"A constant item was initialized with something that is not a constant\nexpression.\n\nErroneous code example:\n\n```compile_fail,E0015\nfn create_some() -> Option<u8> {\n    Some(1)\n}\n\nconst FOO: Option<u8> = create_some(); // error!\n```\n\nThe only functions that can be called in static or constant expressions are\n`const` functions, and struct/enum constructors.\n\nTo fix this error, you can declare `create_some` as a constant function:\n\n```\nconst fn create_some() -> Option<u8> { // declared as a const function\n    Some(1)\n}\n\nconst FOO: Option<u8> = create_some(); // ok!\n\n// These are also working:\nstruct Bar {\n    x: u8,\n}\n\nconst OTHER_FOO: Option<u8> = Some(1);\nconst BAR: Bar = Bar {x: 1};\n```\n"},"level":"error","spans":[{"file_name":"/home/aadit/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/macros.rs","byte_start":1336,"byte_end":1366,"line_start":45,"line_end":45,"column_start":9,"column_end":39,"is_primary":true,"text":[{"text":"        <[_]>::into_vec(box [$($x),+])","highlight_start":9,"highlight_end":39}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/main.rs","byte_start":510,"byte_end":526,"line_start":23,"line_end":23,"column_start":40,"column_end":56,"is_primary":false,"text":[{"text":"const rocket_ptron_shape: Vec<usize> = vec!(8, 8, 8, 2);","highlight_start":40,"highlight_end":56}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"vec!","def_site_span":{"file_name":"/home/aadit/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/macros.rs","byte_start":1148,"byte_end":1375,"line_start":37,"line_end":47,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! vec {","highlight_start":1,"highlight_end":19},{"text":"    () => (","highlight_start":1,"highlight_end":12},{"text":"        $crate::vec::Vec::new()","highlight_start":1,"highlight_end":32},{"text":"    );","highlight_start":1,"highlight_end":7},{"text":"    ($elem:expr; $n:expr) => (","highlight_start":1,"highlight_end":31},{"text":"        $crate::vec::from_elem($elem, $n)","highlight_start":1,"highlight_end":42},{"text":"    );","highlight_start":1,"highlight_end":7},{"text":"    ($($x:expr),+ $(,)?) => (","highlight_start":1,"highlight_end":30},{"text":"        <[_]>::into_vec(box [$($x),+])","highlight_start":1,"highlight_end":39},{"text":"    );","highlight_start":1,"highlight_end":7},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0015]\u001b[0m\u001b[0m\u001b[1m: calls in constants are limited to constant functions, tuple structs and tuple variants\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:23:40\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m23\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mconst rocket_ptron_shape: Vec<usize> = vec!(8, 8, 8, 2);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"aborting due to 5 previous errors; 2 warnings emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 5 previous errors; 2 warnings emitted\u001b[0m\n\n"}
{"message":"Some errors have detailed explanations: E0010, E0015, E0507, E0596.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mSome errors have detailed explanations: E0010, E0015, E0507, E0596.\u001b[0m\n"}
{"message":"For more information about an error, try `rustc --explain E0010`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about an error, try `rustc --explain E0010`.\u001b[0m\n"}
